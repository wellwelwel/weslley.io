---
title: Introduzindo Testes UnitÃ¡rios para Devs Iniciantes
authors: [wellwelwel]
tags: [tests, javascript, beginner]
---

![Banner](./banner.png)

Se vocÃª Ã© um desenvolvedor iniciante (ou nÃ£o), eu quero te mostrar que testes podem sim ser simples e que a complexidade sÃ³ vem conforme nossa prÃ³pria necessidade.

{/* truncate */}

## ğŸ’¡ MotivaÃ§Ã£o

Se vocÃª Ã© um desenvolvedor iniciante (_ou nÃ£o_), eu quero te mostrar que testes podem sim ser simples e que a complexidade sÃ³ vem conforme nossa prÃ³pria necessidade, nÃ£o do _tester_.

<hr />

## ğŸ§‘ğŸ»â€ğŸ“ IntroduÃ§Ã£o ao Mundo dos Testes

Imagine um sistema onde vÃ¡rios usuÃ¡rios tiveram a conta invadida porque criaram senhas como "`1234`" e o sistema permitia, mesmo tendo uma validaÃ§Ã£o para isso, mas sem garantia nenhuma que essa funÃ§Ã£o estava realmente funcionando ğŸ¥²

Isso facilmente seria evitado se existissem testes garantindo que a funÃ§Ã£o que valida a senha funcionasse como deveria sempre que uma modificaÃ§Ã£o Ã© feita no sistema, concorda? ğŸ”

Mas quando um dev iniciante procura por **testes automatizados**, isso pode parecer (_ou atÃ© **ser**_) complexo:

- Os _**testers**_ podem exigir configuraÃ§Ãµes de ambiente (especialmente quando se trata de **ESM** e **TypeScript**)
- Podem mudar o comportamento do ambiente de desenvolvimento
- Podem exigir que vocÃª adapte seu cÃ³digo para funcionar com eles
- E atÃ© que vocÃª tenha um conhecimento previamente aprofundado sobre eles (documentaÃ§Ã£o) para simplesmente iniciar

<hr />

## ğŸ“š Escolhendo o _Tester_

Atualmente, existem muitos testers, alguns focados em boas prÃ¡ticas, outros focados na produtividade, performance e por aÃ­ vai.

Alguns dos mais populares:

- **Jest**
- **Mocha** + **Chai**
- **Vitest**

Para esse tutorial, vamos usar um _tester_ que eu criei ([**Poku**](https://github.com/wellwelwel/poku)), devido sua simplicidade, mas vocÃª pode usar qualquer um ğŸš€

### ğŸ“¦ Instalando nosso **_Tester_**

```bash
npm i -D poku
```

<hr />

## ğŸ§ª Por que "UnitÃ¡rios"?

Ao desenvolvermos nossos cÃ³digos, Ã© comum dividirmos tarefas pequenas em funÃ§Ãµes menores, entÃ£o exportamos essas funÃ§Ãµes para usÃ¡-las em vÃ¡rios lugares no nosso cÃ³digo, certo?

Criar os **testes unitÃ¡rios** garante que essas _"funÃ§Ãµes unitÃ¡rias"_ sempre funcionem como esperado ğŸ§™ğŸ»

> Se essa postagem for **positiva**, eu tambÃ©m gostaria de fazer um tutorial igualmente simples para **testes de integraÃ§Ã£o** e **e2e**, focados para desenvolvedores iniciantes ğŸ¤

<hr />

## ğŸ“‹ Criando um Projeto Simples

Vamos elaborar um projeto bem simples, onde iremos apenas validar uma senha.
Nosso projeto precisa validar se a senha passada:

- âœ… Ã‰ uma string
- âœ… Possui ao menos oito caractÃ©res
- âœ… Possui ao menos uma letra maiÃºscula
- âœ… Possui ao menos uma letra minÃºscula
- âœ… Possui ao menos um nÃºmero

Se a senha for vÃ¡lida, devemos retornar `true`, caso contrÃ¡rio, `false`.

Para isso, iremos criar o arquivo:

- **src/validations.mjs**

```ts
export const validatePassword = (password) => {
  // Verifica se a senha Ã© uma string
  if (typeof password !== 'string') return false;

  // Verifica se a senha possui 8 caractÃ©res ou mais
  if (password.trim().length < 8) return false;

  // Verifica se a senha possui ao menos uma letra maiÃºscula
  if (!/[A-Z]/.test(password)) return false;

  // Verifica se a senha possui ao menos uma letra minÃºscula
  if (!/[a-z]/.test(password)) return false;

  // Verifica se a senha possui ao menos um nÃºmero
  if (!/[0-9]/.test(password)) return false;

  // Retorna verdadeiro se todas as validaÃ§Ãµes acima passarem
  return true;
};
```

> Visando manter o exemplo simples, nÃ£o vamos ir muito alÃ©m disso ğŸ§™ğŸ»

- NÃ£o use essa funÃ§Ã£o para cÃ³digos reais, o intuito Ã© ser simples para focar no apredizado ğŸ§‘ğŸ»â€ğŸ“
- VocÃª pode trocar de **src/validations.mjs** para **src/validations.js** usando o `"type": "module"` no seu arquivo **package.json** ğŸ§™ğŸ»

<hr />

## ğŸ§‘ğŸ»â€ğŸ”¬ Entendendo os Testes

Teoricamente, nossa funÃ§Ã£o do projeto jÃ¡ funciona, esse Ã© o momento que a gente comeÃ§a fazer vÃ¡rios `console.log`, certo? **Nada disso** ğŸ˜‚

Vamos tornar o que seriam esses _"console logs"_, em testes automatizados que sempre serÃ£o executados quando o projeto passar por uma alteraÃ§Ã£o ğŸš€

Como? Usando asserÃ§Ãµes ğŸ‘‡ğŸ»

<hr />

### â˜‘ï¸ O que sÃ£o AsserÃ§Ãµes?

Nos testes, **asserÃ§Ãµes** sÃ£o usadas para garantir que um resultado Ã© realmente o que a gente espera.

Cada _tester_ pode ter uma forma diferente de fazer isso, mas o final costuma ser o mesmo:

- Se nossa verificaÃ§Ã£o (asserÃ§Ã£o) nÃ£o for exatamente como o esperado, o teste irÃ¡ disparar um erro nessa asserÃ§Ã£o.

#### ğŸ“ Exemplo:

Imagine que `1 + 1` precisa retornar `2`, mas retornou `"11"`.

Quando chegar na asserÃ§Ã£o que espera o resultado `2`, ela irÃ¡ disparar um erro no teste dizendo que esperava `2` (nÃºmero), mas recebeu `"11"` (_string_):

```js
import { assert } from 'poku';

assert.strictEqual('1' + '1', 2, '1+1 deve retornar 2');
```

<img
  loading='lazy'
  width='474'
  alt='Erro de asserÃ§Ã£o'
  src='https://github.com/wellwelwel/poku/assets/46850407/f1dc1e18-7f9b-4ccb-880c-b0845464925f'
/>

- `actual`:
  - _"11"_ â€” Ã‰ o retorno dinÃ¢mico (_soft code_) da nossa funÃ§Ã£o ou variÃ¡vel
- `expected`:
  - _2_ â€” Ã© o valor bruto (_hard code_) que deve ser retornado pelo `actual`

> Tanto o [**Poku**](https://github.com/wellwelwel/poku) como o prÃ³prio **Node.js** possuem o mÃ©todo `assert` com a forma de uso exatamente iguais ğŸ§™ğŸ»
>
> Quanto ao funcionamento, o [**Poku**](https://github.com/wellwelwel/poku) oferece uma forma simples e inteligente de executar mÃºltiplos arquivos e descreve todas as asserÃ§Ãµes que passaram ou nÃ£o no terminal ğŸ·

#### ğŸ“ Corrigindo nosso exemplo:

```js
import { assert } from 'poku';

assert.strictEqual(1 + 1, 2, '1+1 deve retornar 2');
```

<img
  loading='lazy'
  width='474'
  alt='AsserÃ§Ã£o com sucesso'
  src='https://github.com/wellwelwel/poku/assets/46850407/430a72eb-8d34-45f4-abc7-2f2f92e3dd8e'
/>

<hr />

## ğŸ§ª Criando os Testes

> Finalmente a parte boa ğŸ‰

Para isso, vamos usar a criatividade e gerar:

- âŒ VÃ¡rias senhas invÃ¡lidas para simular o comportamento tanto de usuÃ¡rios usuais, como de usuÃ¡rios mal intencionados
  - Nas senhas invÃ¡lidas, nÃ³s esperamos (`expected`) que o resultado (`actual`) seja `false`.
- âœ… Senhas vÃ¡lidas para garantir que nossa funÃ§Ã£o entende que a senha deve ser vÃ¡lida quando passar por todos os critÃ©rios
  - Nas senhas vÃ¡lidas, nÃ³s esperamos (`expected`) que o resultado (`actual`) seja `true`.
- ğŸ“ Nada de comentÃ¡rios no teste, vamos descrever o que Ã© cada um na prÃ³pria asserÃ§Ã£o (`message`)

Vamos criar nosso arquivo de teste:

- **test/password.test.mjs**

```js
import { assert } from 'poku';
import { validatePassword } from '../src/validations.mjs';

assert.strictEqual(
  validatePassword(),
  false,
  'Valida se a senha nÃ£o for passada'
);

assert.strictEqual(
  validatePassword(12345678),
  false,
  'Valida se a senha nÃ£o for uma string'
);

assert.strictEqual(
  validatePassword(''),
  false,
  'Valida se a senha for uma string vazia'
);

assert.strictEqual(
  validatePassword('abcd1234'),
  false,
  'Valida se a senha nÃ£o possuir ao menos uma letra maiÃºscula'
);

assert.strictEqual(
  validatePassword('1234EFGH'),
  false,
  'Valida se a senha nÃ£o possuir ao menos uma letra minÃºscula'
);

assert.strictEqual(
  validatePassword('abcdEFGH'),
  false,
  'Valida se a senha nÃ£o possuir ao menos um nÃºmero'
);

assert.strictEqual(
  validatePassword('abcdEF12'),
  true,
  'Valida se a senha for vÃ¡lida'
);
```

- VocÃª pode trocar de **test/password.test.mjs** para **test/password.test.js** usando o `"type": "module"` no seu arquivo **package.json** ğŸ§™ğŸ»

<hr />

## ğŸ”¬ Verificando se os Testes Passaram

```bash
npx poku
```

- Ao executar o comando `npx poku`, por padrÃ£o, o _tester_ irÃ¡ procurar por todos os arquivos com a extenÃ§Ã£o `*.test.*` ou `*.spec.*` no diretÃ³rio em que o comando foi executado ğŸ§™ğŸ»

E finalmente, nosso resultado:

<img
  loading='lazy'
  width='522'
  alt='Exemplo de Sucesso com o Poku'
  src='https://github.com/wellwelwel/poku/assets/46850407/f06105a3-f956-473f-b456-26c1e27d80db'
/>

- A primeira saÃ­da mostra em qual diretÃ³rio o [**Poku**](https://github.com/wellwelwel/poku) estÃ¡ procurando por testes
- A segunda saÃ­da mostra o arquivo que estÃ¡ sendo testado no momento
  - Dentro de cada arquivo de teste, ele irÃ¡ mostrar todas as asserÃ§Ãµes que possuÃ­rem uma mensagem
  - Ao finalizar, seja com sucesso ou erro, ele irÃ¡ mostrar o comando que ele executou para o arquivo testado:
    - `node test/password.test.mjs`
- Quando todos os arquivos de testes terminarem, ele irÃ¡ mostrar um resumo de quantos arquivos passaram e/ou falharam
- No final, o cÃ³digo de saÃ­da serÃ¡:
  - âœ… `0` para sucesso
  - âŒ `1` para falha

<hr />

## ğŸ’­ ConclusÃ£o

Com os **testes unitÃ¡rios** que criamos, nÃ³s garantimos nÃ£o sÃ³ que nossa funÃ§Ã£o funcione como deveria, como inclusive prevemos como nosso projeto reage em situaÃ§Ãµes atÃ­picas antes que elas aconteÃ§am ğŸ”

> Espero ter te provado que **testes** podem sim (!) ser **simples** ğŸ§‘ğŸ»â€ğŸ“

<hr />

- Essa foi minha primeira "aula" em formato de _blog_. Feedbacks sÃ£o sempre bem vindos ğŸ©µ
- Muitos termos sÃ£o explicados repetidamente em momentos diferentes, isso Ã© uma escolha didÃ¡tica, mas podem falar caso tenha ficado cansativo ğŸ§‘ğŸ»â€ğŸ“

:::info
Esse artigo foi postado icialmente no [TabNews](https://www.tabnews.com.br/wellwelwel/tutorial-introduzindo-testes-unitarios-para-devs-iniciantes-js).
:::
